# Telegram AI Bot Project Context & Goal

## Goal for the LLM
You are an expert Python developer and AI bot architect with deep expertise in:
- Telegram Bot API and python-telegram-bot library
- AI/LLM integration (OpenAI/OpenRouter APIs)
- Database design with Supabase/PostgreSQL
- Modern Python development with UV package manager
- Bot conversation design and user experience

Your task is to analyze the complete context of this Telegram AI Bot project. The bot features:
- Two AI personalities (Product Manager & VC/Angel Investor)
- Conversation persistence with Supabase
- Real-time AI responses via OpenRouter/Perplexity
- Rich Telegram UI with inline keyboards
- User statistics and session management

Please review the project structure, dependencies, source code, database schema, and configuration,
then provide specific, actionable advice for improvement. Focus on:
- Code quality and Python best practices
- Bot conversation flow and UX
- Database optimization and design
- AI prompt engineering and response quality
- Security and error handling
- Performance and scalability
- Deployment and production readiness

---

## Directory Structure
.
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ generate-context.sh
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ migrations
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 001_initial_schema.sql
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ render.yaml
‚îú‚îÄ‚îÄ scripts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_supabase.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_telegram_bot.py
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ bot
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __main__.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ agents.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ config.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ database.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ handlers.py
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ telegram-bot-context-prompt-20250807-1455.txt
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ test_database.py

6 directories, 18 files

## FILE: README.md

---

## FILE: pyproject.toml
[project]
name = "telegram-ai-bot"
version = "0.1.0"
description = "AI-powered Telegram bot with PM and VC personalities"
readme = "README.md"
requires-python = ">=3.11"
dependencies = [
    "python-telegram-bot>=20.7",
    "openai>=1.35.3",
    "supabase>=2.3.0",
    "python-dotenv>=1.0.0",
    "pydantic>=2.5.0",
    "aiohttp>=3.9.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/bot"]

[tool.uv]
dev-dependencies = [
    "pytest>=7.4.0",
    "pytest-asyncio>=0.21.0",
    "black>=23.0.0",
    "ruff>=0.1.0",
    "mypy>=1.7.0",
    "ipython>=8.0.0",
]

[tool.ruff]
line-length = 88
target-version = "py311"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "UP", "ANN", "B", "A", "COM", "C4", "DTZ", "ISC", "ICN", "PIE", "PT", "RET", "SIM", "ARG"]
# ANN101 and ANN102 have been removed from ruff, so no need to ignore them

[tool.mypy]
python_version = "3.11"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
---

## FILE: .env.example
# Supabase
SUPABASE_URL=https://xxxxxxxxxxxx.supabase.co
SUPABASE_SERVICE_KEY=your-service-key-here

# OpenRouter
OPENROUTER_API_KEY=sk-or-v1-xxxxx

# Telegram
TELEGRAM_BOT_TOKEN=123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11

# Environment
ENVIRONMENT=development
LOG_LEVEL=INFO
---

## FILE: .gitignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv/

# UV
.uv/
uv.lock

# Environment
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# Project specific
*.log
*.db
.DS_Store
---

## FILE: render.yaml
services:
  - type: web
    name: telegram-ai-bot
    env: python
    buildCommand: "pip install uv && uv sync"
    startCommand: "uv run python -m bot.main"
    envVars:
      - key: SUPABASE_URL
        sync: false
      - key: SUPABASE_SERVICE_KEY
        sync: false
      - key: OPENROUTER_API_KEY
        sync: false
      - key: TELEGRAM_BOT_TOKEN
        sync: false
      - key: ENVIRONMENT
        value: production
      - key: LOG_LEVEL
        value: INFO
---

## FILE: ./generate-context.sh
#!/bin/bash
#
# Description:
# This script generates a comprehensive prompt for an LLM by concatenating key source
# files from the Telegram AI Bot project, including Python bot code, database schemas,
# configuration files, and project structure.
#
# Usage:
# ./generate-context.sh
#

# --- Configuration ---

# Get current date for the output filename
DATE=$(date +%Y%m%d-%H%M)

# Output filename with a timestamp
OUTPUT_FILE="telegram-bot-context-prompt-${DATE}.txt"

# --- Script Body ---

# Clean up any previous output file to start fresh
rm -f "$OUTPUT_FILE"

echo "üöÄ Starting LLM prompt generation for the Telegram AI Bot project..."
echo "------------------------------------------------------------"
echo "Output will be saved to: $OUTPUT_FILE"
echo ""

# 1. Add a Preamble and Goal for the LLM
echo "Adding LLM preamble and goal..."
{
  echo "# Telegram AI Bot Project Context & Goal"
  echo ""
  echo "## Goal for the LLM"
  echo "You are an expert Python developer and AI bot architect with deep expertise in:"
  echo "- Telegram Bot API and python-telegram-bot library"
  echo "- AI/LLM integration (OpenAI/OpenRouter APIs)"
  echo "- Database design with Supabase/PostgreSQL"
  echo "- Modern Python development with UV package manager"
  echo "- Bot conversation design and user experience"
  echo ""
  echo "Your task is to analyze the complete context of this Telegram AI Bot project. The bot features:"
  echo "- Two AI personalities (Product Manager & VC/Angel Investor)"
  echo "- Conversation persistence with Supabase"
  echo "- Real-time AI responses via OpenRouter/Perplexity"
  echo "- Rich Telegram UI with inline keyboards"
  echo "- User statistics and session management"
  echo ""
  echo "Please review the project structure, dependencies, source code, database schema, and configuration,"
  echo "then provide specific, actionable advice for improvement. Focus on:"
  echo "- Code quality and Python best practices"
  echo "- Bot conversation flow and UX"
  echo "- Database optimization and design"
  echo "- AI prompt engineering and response quality"
  echo "- Security and error handling"
  echo "- Performance and scalability"
  echo "- Deployment and production readiness"
  echo ""
  echo "---"
  echo ""
} >> "$OUTPUT_FILE"

# 2. Add the project's directory structure (cleaned up)
echo "Adding cleaned directory structure..."
echo "## Directory Structure" >> "$OUTPUT_FILE"
if command -v tree &> /dev/null; then
    echo "  -> Adding directory structure (tree -L 4)"
    # Exclude common noise from the tree view
    tree -L 4 -I "__pycache__|.venv|venv|.git|.pytest_cache|.ruff_cache|.mypy_cache|htmlcov|*.pyc|uv.lock" >> "$OUTPUT_FILE"
else
    echo "  -> WARNING: 'tree' command not found. Using ls -la instead."
    echo "NOTE: 'tree' command was not found. Directory listing:" >> "$OUTPUT_FILE"
    ls -la >> "$OUTPUT_FILE"
fi
echo "" >> "$OUTPUT_FILE"

# 3. Add Core Project and Configuration Files
echo "Adding core project and configuration files..."
# Core files that provide project context
CORE_FILES=(
  "README.md"
  "pyproject.toml"
  ".env.example"
  ".gitignore"
  "render.yaml"
  "$0" # This script itself
)

for file in "${CORE_FILES[@]}"; do
  if [ -f "$file" ]; then
    echo "  -> Adding $file"
    echo "## FILE: $file" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
  else
    echo "  -> WARNING: $file not found. Skipping."
  fi
done

# 4. Add all Python source files from src/bot/
echo "Adding all Python source files from 'src/bot/'..."
# Find all Python files, excluding common directories we don't want
find "src/bot" -type f -name "*.py" \
  -not -path "*/.venv/*" \
  -not -path "*/venv/*" \
  -not -path "*/__pycache__/*" \
  -not -path "*/.pytest_cache/*" \
  | while read -r py_file; do
    echo "  -> Adding Python file: $py_file"
    echo "## FILE: $py_file" >> "$OUTPUT_FILE"
    cat "$py_file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
  done

# 5. Add test files
echo "Adding test files from 'tests/'..."
if [ -d "tests" ]; then
  find "tests" -type f -name "*.py" \
    -not -path "*/__pycache__/*" \
    | while read -r test_file; do
      echo "  -> Adding test file: $test_file"
      echo "## FILE: $test_file" >> "$OUTPUT_FILE"
      cat "$test_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
else
  echo "  -> No tests directory found. Skipping."
fi

# 6. Add script files
echo "Adding script files from 'scripts/'..."
if [ -d "scripts" ]; then
  find "scripts" -type f -name "*.py" \
    | while read -r script_file; do
      echo "  -> Adding script file: $script_file"
      echo "## FILE: $script_file" >> "$OUTPUT_FILE"
      cat "$script_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
else
  echo "  -> No scripts directory found. Skipping."
fi

# 7. Add database migration files
echo "Adding database migration files from 'migrations/'..."
if [ -d "migrations" ]; then
  find "migrations" -type f \( -name "*.sql" -o -name "*.py" \) \
    | while read -r migration_file; do
      echo "  -> Adding migration file: $migration_file"
      echo "## FILE: $migration_file" >> "$OUTPUT_FILE"
      cat "$migration_file" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
      echo "---" >> "$OUTPUT_FILE"
      echo "" >> "$OUTPUT_FILE"
    done
else
  echo "  -> No migrations directory found. Skipping."
fi

# 8. Add any additional Python files in the root
echo "Adding any additional Python files in root..."
find . -maxdepth 1 -type f -name "*.py" \
  | while read -r root_py_file; do
    echo "  -> Adding root Python file: $root_py_file"
    echo "## FILE: $root_py_file" >> "$OUTPUT_FILE"
    cat "$root_py_file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
  done

# --- Completion Summary ---

echo ""
echo "-------------------------------------"
echo "‚úÖ Prompt generation complete!"
echo ""
echo "This context file now includes:"
echo "  ‚úì A clear goal and preamble for the LLM"
echo "  ‚úì A cleaned project directory structure"
echo "  ‚úì Core project files (README.md, pyproject.toml, .env.example)"
echo "  ‚úì Configuration files (.gitignore, render.yaml)"
echo "  ‚úì This generation script itself"
echo "  ‚úì All Python source code from the 'src/bot' directory (*.py)"
echo "  ‚úì All test files from the 'tests' directory"
echo "  ‚úì All script files from the 'scripts' directory"
echo "  ‚úì All database migration files from the 'migrations' directory"
echo "  ‚úì Any additional Python files in the root directory"
echo ""
echo "File size: $(du -h "$OUTPUT_FILE" | cut -f1)"
echo "Total lines: $(wc -l < "$OUTPUT_FILE" | xargs)"
echo ""
echo "You can now use the content of '$OUTPUT_FILE' as a context prompt for your LLM."
echo "Perfect for getting comprehensive code reviews, architecture advice, or feature suggestions!"
echo ""
echo "üí° Tip: This is especially useful for:"
echo "   - Code reviews and optimization suggestions"
echo "   - Bot conversation flow improvements"
echo "   - Database schema optimization"
echo "   - AI prompt engineering enhancements"
echo "   - Production deployment planning"

---

## FILE: src/bot/config.py
"""Bot configuration and constants."""

import os

from dotenv import load_dotenv

load_dotenv()

# Environment variables
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_SERVICE_KEY = os.getenv("SUPABASE_SERVICE_KEY")

# Validate required environment variables
required_vars = {
    "TELEGRAM_BOT_TOKEN": TELEGRAM_BOT_TOKEN,
    "OPENROUTER_API_KEY": OPENROUTER_API_KEY,
    "SUPABASE_URL": SUPABASE_URL,
    "SUPABASE_SERVICE_KEY": SUPABASE_SERVICE_KEY,
}

missing_vars = [var for var, value in required_vars.items() if not value]
if missing_vars:
    raise ValueError(
        f"Missing required environment variables: {', '.join(missing_vars)}",
    )

# Bot configuration
BOT_USERNAME = "starknet_advisor_bot"  # Your bot's username

# Agent configurations with Perplexity models
AGENTS: dict[str, dict] = {
    "pm": {
        "name": "üöÄ Product Manager",
        "description": "Product strategy expert based on Lenny Rachitsky's frameworks",
        "model": "perplexity/llama-3.1-sonar-large-128k-online",
        "system_prompt": """You are Lenny Rachitsky, the renowned product strategy expert. 
You have access to:
- All of Lenny's Newsletter content and frameworks
- Current market data and product trends
- Real-time information about successful products

Focus on:
1. Jobs-to-be-Done framework for product-market fit
2. User research and persona development
3. Growth loops and retention strategies
4. Prioritization frameworks (RICE, ICE)
5. Building minimum lovable products

Always provide specific, actionable advice with real examples. 
Be conversational but insightful.""",
    },
    "vc": {
        "name": "ü¶à Seed VC / Angel Investor",
        "description": "Early-stage investor with current market insights",
        "model": "perplexity/llama-3.1-sonar-large-128k-online",
        "system_prompt": """You are an experienced seed-stage investor and angel investor 
with access to:
- Current funding market data and trends
- Recent successful fundraising examples
- Real-time valuations and metrics

Focus on:
1. Market timing and TAM analysis
2. Founder-market fit assessment
3. Early traction metrics that matter
4. Unit economics and burn rate
5. Fundraising strategy and deck feedback

Be direct but constructive. Reference recent funding rounds and current market 
conditions.""",
    },
}

# Rate limiting
RATE_LIMIT_MESSAGES = 30  # messages per user per hour
RATE_LIMIT_WINDOW = 3600  # 1 hour in seconds

# Message settings
MAX_MESSAGE_LENGTH = 4000
MAX_HISTORY_MESSAGES = 10  # How many previous messages to include in context

---

## FILE: src/bot/database.py
"""Database operations using Supabase."""

import logging
import os
from datetime import UTC, datetime

from dotenv import load_dotenv
from supabase import Client, create_client

load_dotenv()

logger = logging.getLogger(__name__)


class Database:
    """Handle all database operations."""

    def __init__(self) -> None:
        self.client: Client = create_client(
            os.getenv("SUPABASE_URL"),
            os.getenv("SUPABASE_SERVICE_KEY"),
        )

    async def save_message(
        self,
        user_id: str,
        username: str | None,
        first_name: str | None,
        agent_type: str,
        role: str,
        message: str,
        tokens_used: int = 0,
    ) -> dict:
        """Save a message to the database."""
        try:
            result = (
                self.client.table("conversations")
                .insert(
                    {
                        "user_id": user_id,
                        "username": username,
                        "first_name": first_name,
                        "agent_type": agent_type,
                        "role": role,
                        "message": message,
                        "tokens_used": tokens_used,
                    },
                )
                .execute()
            )
            return result.data[0] if result.data else {}
        except Exception as e:
            logger.error(f"Error saving message: {e}")
            raise

    async def get_conversation_history(
        self,
        user_id: str,
        agent_type: str,
        limit: int = 10,
    ) -> list[dict]:
        """Get recent conversation history."""
        try:
            result = (
                self.client.table("conversations")
                .select("*")
                .eq("user_id", user_id)
                .eq("agent_type", agent_type)
                .order("created_at", desc=True)
                .limit(limit)
                .execute()
            )

            # Return in chronological order
            return list(reversed(result.data)) if result.data else []
        except Exception as e:
            logger.error(f"Error getting conversation history: {e}")
            return []

    async def update_user_session(
        self,
        user_id: str,
        username: str | None,
        first_name: str | None,
        agent_type: str,
    ) -> None:
        """Update or create user session."""
        try:
            # Upsert user session
            self.client.table("user_sessions").upsert(
                {
                    "user_id": user_id,
                    "username": username,
                    "first_name": first_name,
                    "current_agent": agent_type,
                    "last_active": datetime.now(UTC).isoformat(),
                },
            ).execute()
        except Exception as e:
            logger.error(f"Error updating user session: {e}")

    async def clear_conversation(
        self,
        user_id: str,
        agent_type: str | None = None,
    ) -> None:
        """Clear conversation history for a user."""
        try:
            query = self.client.table("conversations").delete().eq("user_id", user_id)

            if agent_type:
                query = query.eq("agent_type", agent_type)

            query.execute()
            logger.info(f"Cleared conversations for user {user_id}")
        except Exception as e:
            logger.error(f"Error clearing conversations: {e}")

    async def get_user_stats(self, user_id: str) -> dict:
        """Get user statistics."""
        try:
            # Get message counts
            total_messages = (
                self.client.table("conversations")
                .select("id", count="exact")
                .eq("user_id", user_id)
                .eq("role", "user")
                .execute()
            )

            pm_messages = (
                self.client.table("conversations")
                .select("id", count="exact")
                .eq("user_id", user_id)
                .eq("agent_type", "pm")
                .eq("role", "user")
                .execute()
            )

            vc_messages = (
                self.client.table("conversations")
                .select("id", count="exact")
                .eq("user_id", user_id)
                .eq("agent_type", "vc")
                .eq("role", "user")
                .execute()
            )

            # Get first message date
            first_message = (
                self.client.table("conversations")
                .select("created_at")
                .eq("user_id", user_id)
                .order("created_at")
                .limit(1)
                .execute()
            )

            return {
                "total_messages": total_messages.count or 0,
                "pm_messages": pm_messages.count or 0,
                "vc_messages": vc_messages.count or 0,
                "first_message_date": (
                    first_message.data[0]["created_at"] if first_message.data else None
                ),
            }
        except Exception as e:
            logger.error(f"Error getting user stats: {e}")
            return {
                "total_messages": 0,
                "pm_messages": 0,
                "vc_messages": 0,
                "first_message_date": None,
            }

---

## FILE: src/bot/handlers.py
"""Telegram bot command handlers."""

import logging
from datetime import UTC, datetime

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.constants import ChatAction, ParseMode
from telegram.ext import ContextTypes

from .agents import AIAgent
from .config import AGENTS
from .database import Database

logger = logging.getLogger(__name__)


class BotHandlers:
    """Handles all bot commands and messages."""

    def __init__(self) -> None:
        self.db = Database()
        self.ai = AIAgent()

    async def start(self, update: Update, _context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle /start command."""
        user = update.effective_user

        # Create agent selection keyboard
        keyboard = [
            [
                InlineKeyboardButton(
                    AGENTS["pm"]["name"],
                    callback_data="select_pm",
                )
            ],
            [
                InlineKeyboardButton(
                    AGENTS["vc"]["name"],
                    callback_data="select_vc",
                )
            ],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        welcome_message = f"""
üéØ **Welcome to Starknet Startup Advisor Bot!**

Hi {user.first_name}! I'm your AI-powered startup advisor with two expert personalities:

{AGENTS["pm"]["name"]} **Product Manager**
_Based on Lenny Rachitsky's frameworks_
- Product-market fit strategies
- User research & personas
- Growth & retention tactics
- Feature prioritization

{AGENTS["vc"]["name"]} **Seed VC / Angel**
_Current market insights_
- Market analysis & TAM
- Fundraising strategy
- Pitch deck feedback
- Traction metrics

Choose your advisor to begin:
"""

        await update.message.reply_text(
            welcome_message,
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN,
        )

        # Update user session
        await self.db.update_user_session(
            user_id=str(user.id),
            username=user.username,
            first_name=user.first_name,
            agent_type="pm",  # Default
        )

    async def handle_agent_selection(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Handle agent selection from inline keyboard."""
        query = update.callback_query
        await query.answer()

        user = update.effective_user
        agent_type = query.data.replace("select_", "")

        # Update user session
        await self.db.update_user_session(
            user_id=str(user.id),
            username=user.username,
            first_name=user.first_name,
            agent_type=agent_type,
        )

        # Store in context for quick access
        context.user_data["agent_type"] = agent_type

        agent_name = AGENTS[agent_type]["name"]
        agent_desc = AGENTS[agent_type]["description"]

        start_prompts = {
            "pm": [
                "What's your product idea?",
                "Tell me about your target users",
                "What problem are you solving?",
            ],
            "vc": [
                "What's your startup idea?",
                "Tell me about your market",
                "What traction do you have?",
            ],
        }

        prompts = "\n‚Ä¢ ".join(start_prompts[agent_type])

        await query.edit_message_text(
            f"""
‚úÖ **{agent_name} Selected!**

{agent_desc}

Ready to help! You can start by sharing:
- {prompts}

Or just tell me what's on your mind about your startup.

üí° _Tip: You can switch advisors anytime with /pm or /vc_
""",
            parse_mode=ParseMode.MARKDOWN,
        )

    async def handle_message(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Handle regular text messages."""
        user = update.effective_user
        message = update.message.text

        # Get or set agent type
        agent_type = context.user_data.get("agent_type", "pm")

        # Show typing indicator
        await context.bot.send_chat_action(
            chat_id=update.effective_chat.id,
            action=ChatAction.TYPING,
        )

        try:
            # Save user message
            await self.db.save_message(
                user_id=str(user.id),
                username=user.username,
                first_name=user.first_name,
                agent_type=agent_type,
                role="user",
                message=message,
            )

            # Get conversation history
            history = await self.db.get_conversation_history(
                user_id=str(user.id),
                agent_type=agent_type,
                limit=10,
            )

            # Get AI response
            ai_response, tokens = await self.ai.get_response(
                agent_type=agent_type,
                messages=history,
                user_message=message,
            )

            # Save AI response
            await self.db.save_message(
                user_id=str(user.id),
                username=user.username,
                first_name=user.first_name,
                agent_type=agent_type,
                role="assistant",
                message=ai_response,
                tokens_used=tokens,
            )

            # Send response
            await update.message.reply_text(
                ai_response,
                parse_mode=ParseMode.MARKDOWN,
            )

        except Exception as e:
            logger.error(f"Error handling message: {e}")
            await update.message.reply_text(
                "Sorry, I encountered an error. Please try again.",
            )

    async def switch_to_pm(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Handle /pm command."""
        await self._switch_agent(update, context, "pm")

    async def switch_to_vc(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Handle /vc command."""
        await self._switch_agent(update, context, "vc")

    async def _switch_agent(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        agent_type: str,
    ) -> None:
        """Switch to a different agent."""
        user = update.effective_user

        # Update session
        await self.db.update_user_session(
            user_id=str(user.id),
            username=user.username,
            first_name=user.first_name,
            agent_type=agent_type,
        )

        context.user_data["agent_type"] = agent_type

        agent_name = AGENTS[agent_type]["name"]
        await update.message.reply_text(
            f"‚úÖ Switched to **{agent_name}**\n\nHow can I help you?",
            parse_mode=ParseMode.MARKDOWN,
        )

    async def reset(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Handle /reset command."""
        user = update.effective_user
        agent_type = context.user_data.get("agent_type", "pm")

        # Clear conversation history for current agent
        await self.db.clear_conversation(user_id=str(user.id), agent_type=agent_type)

        agent_name = AGENTS[agent_type]["name"]
        await update.message.reply_text(
            f"üîÑ **Conversation Reset!**\n\nYour conversation history with {agent_name} has been cleared.\n\nLet's start fresh! What would you like to discuss?",
            parse_mode=ParseMode.MARKDOWN,
        )

    async def stats(
        self,
        update: Update,
        _context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Handle /stats command."""
        user = update.effective_user

        # Get user stats
        stats = await self.db.get_user_stats(str(user.id))

        # Format dates
        if stats["first_message_date"]:
            first_date = datetime.fromisoformat(
                stats["first_message_date"].replace("Z", "+00:00")
            )
            days_active = (datetime.now(UTC) - first_date.replace(tzinfo=None)).days
            member_since = first_date.strftime("%B %d, %Y")
        else:
            days_active = 0
            member_since = "Today"

        stats_message = f"""
üìä **Your Statistics**

üë§ **User:** {user.first_name or 'Founder'}
üìÖ **Member Since:** {member_since}
‚è±Ô∏è **Days Active:** {days_active}

üí¨ **Total Messages:** {stats['total_messages']}
‚îú‚îÄ üöÄ Product Manager: {stats['pm_messages']}
‚îî‚îÄ ü¶à VC/Angel: {stats['vc_messages']}

üèÜ **Favorite Advisor:** {'Product Manager' if stats['pm_messages'] > stats['vc_messages'] else 'VC/Angel' if stats['vc_messages'] > stats['pm_messages'] else 'Tie!'}

Keep building! üöÄ
"""

        await update.message.reply_text(
            stats_message,
            parse_mode=ParseMode.MARKDOWN,
        )

    async def help_command(
        self,
        update: Update,
        _context: ContextTypes.DEFAULT_TYPE,
    ) -> None:
        """Handle /help command."""
        help_text = """
üìö **How to use this bot:**

**Commands:**
- /start - Choose your advisor
- /pm - Switch to Product Manager
- /vc - Switch to VC/Angel Investor  
- /reset - Clear conversation history
- /stats - View your usage stats
- /help - Show this help message

**Tips:**
- Be specific about your startup/product
- Ask follow-up questions
- Share your challenges openly
- The AI has internet access for current data

**Current advisor:** Check the bot's responses - they'll show which personality is active.

Questions? Contact @espejelomar
"""

        await update.message.reply_text(
            help_text,
            parse_mode=ParseMode.MARKDOWN,
        )

---

## FILE: src/bot/__init__.py
"""Telegram AI Bot with PM and VC personalities."""

__version__ = "0.1.0"

---

## FILE: src/bot/agents.py
"""AI agent configurations and OpenRouter integration."""

import logging
import os

from dotenv import load_dotenv
from openai import AsyncOpenAI

load_dotenv()

logger = logging.getLogger(__name__)


class AIAgent:
    """Manages AI agent interactions with OpenRouter."""

    def __init__(self) -> None:
        self.client = AsyncOpenAI(
            base_url="https://openrouter.ai/api/v1",
            api_key=os.getenv("OPENROUTER_API_KEY"),
        )

        # Agent configurations
        self.agents = {
            "pm": {
                "name": "üöÄ Product Manager",
                "model": "perplexity/llama-3.1-sonar-large-128k-online",
                "system_prompt": """You are Lenny Rachitsky, the renowned product strategy expert. You have access to:
- All of Lenny's Newsletter content and frameworks
- Current market data and product trends
- Real-time information about successful products

Focus on:
1. Jobs-to-be-Done framework for product-market fit
2. User research and persona development  
3. Growth loops and retention strategies
4. Prioritization frameworks (RICE, ICE)
5. Building minimum lovable products

Always provide specific, actionable advice with real examples. Be conversational but insightful.
When users share ideas, ask probing questions like Lenny would.""",
            },
            "vc": {
                "name": "ü¶à Seed VC / Angel Investor",
                "model": "perplexity/llama-3.1-sonar-large-128k-online",
                "system_prompt": """You are an experienced seed-stage investor and angel investor with access to:
- Current funding market data and trends
- Recent successful fundraising examples
- Real-time valuations and metrics

Focus on:
1. Market timing and TAM analysis
2. Founder-market fit assessment
3. Early traction metrics that matter
4. Unit economics and burn rate
5. Fundraising strategy and deck feedback

Be direct but constructive. Reference recent funding rounds and current market conditions.
Challenge assumptions like a real investor would.""",
            },
        }

    async def get_response(
        self,
        agent_type: str,
        messages: list[dict[str, str]],
        user_message: str,
    ) -> tuple[str, int]:
        """Get AI response for the given agent type."""
        try:
            agent = self.agents[agent_type]

            # Build message history
            formatted_messages = [
                {"role": "system", "content": agent["system_prompt"]},
            ]

            # Add conversation history
            for msg in messages[-10:]:  # Last 10 messages
                formatted_messages.append(
                    {
                        "role": msg["role"],
                        "content": msg["message"],
                    }
                )

            # Add current message
            formatted_messages.append(
                {
                    "role": "user",
                    "content": user_message,
                }
            )

            # Get AI response
            response = await self.client.chat.completions.create(
                model=agent["model"],
                messages=formatted_messages,
                max_tokens=800,
                temperature=0.7,
            )

            content = response.choices[0].message.content
            tokens = response.usage.total_tokens if response.usage else 0

            return content, tokens

        except Exception as e:
            logger.error(f"Error getting AI response: {e}")
            return (
                "I apologize, but I'm having trouble processing your request. Please try again.",
                0,
            )

---

## FILE: src/bot/main.py
"""Main bot application."""

import logging
import sys

from telegram import Update
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    MessageHandler,
    filters,
)

from .config import TELEGRAM_BOT_TOKEN
from .handlers import BotHandlers

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)


def main() -> None:
    """Start the bot."""
    # Create application
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Initialize handlers
    handlers = BotHandlers()

    # Register command handlers
    application.add_handler(CommandHandler("start", handlers.start))
    application.add_handler(CommandHandler("pm", handlers.switch_to_pm))
    application.add_handler(CommandHandler("vc", handlers.switch_to_vc))
    application.add_handler(CommandHandler("reset", handlers.reset))
    application.add_handler(CommandHandler("stats", handlers.stats))
    application.add_handler(CommandHandler("help", handlers.help_command))

    # Register callback query handler for inline keyboards
    application.add_handler(
        CallbackQueryHandler(
            handlers.handle_agent_selection,
            pattern="^select_",
        )
    )

    # Register message handler for regular text
    application.add_handler(
        MessageHandler(
            filters.TEXT & ~filters.COMMAND,
            handlers.handle_message,
        )
    )

    # Start the bot
    logger.info("Starting bot...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
        sys.exit(0)
    except Exception as e:
        logger.error(f"Fatal error: {e}")
        sys.exit(1)

---

## FILE: src/bot/__main__.py
"""Allow running bot as module: python -m bot"""

from .main import main

if __name__ == "__main__":
    main()

---

## FILE: tests/test_database.py
"""Tests for database operations."""
import pytest
from unittest.mock import Mock, patch
from src.bot.database import Database


class TestDatabase:
    """Test cases for Database class."""
    
    @patch('src.bot.database.create_client')
    def test_database_init(self, mock_create_client):
        """Test database initialization."""
        mock_client = Mock()
        mock_create_client.return_value = mock_client
        
        db = Database()
        
        assert db.client == mock_client
        mock_create_client.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_save_message_success(self):
        """Test successful message saving."""
        # This will be implemented when we have actual Supabase setup
        pass
    
    @pytest.mark.asyncio
    async def test_get_conversation_history_success(self):
        """Test successful conversation history retrieval."""
        # This will be implemented when we have actual Supabase setup
        pass
---

## FILE: tests/__init__.py
# Tests package
---

## FILE: scripts/test_supabase.py
"""Test script for Supabase connection."""

import asyncio
import os
from dotenv import load_dotenv
from supabase import create_client

load_dotenv()


async def test_supabase_connection():
    """Test Supabase connection and basic operations."""
    try:
        # Initialize Supabase client
        supabase = create_client(
            os.getenv("SUPABASE_URL"), os.getenv("SUPABASE_SERVICE_KEY")
        )

        print("‚úÖ Supabase client created successfully")

        # Test a simple query (this will fail if tables don't exist yet)
        try:
            result = supabase.table("conversations").select("*").limit(1).execute()
            print(f"‚úÖ Conversations table query successful: {len(result.data)} rows")
        except Exception as e:
            print(
                f"‚ö†Ô∏è  Conversations table query failed (expected if tables don't exist): {e}"
            )

        try:
            result = supabase.table("user_sessions").select("*").limit(1).execute()
            print(f"‚úÖ User sessions table query successful: {len(result.data)} rows")
        except Exception as e:
            print(
                f"‚ö†Ô∏è  User sessions table query failed (expected if tables don't exist): {e}"
            )

        print("\nüéØ Supabase connection test completed!")

    except Exception as e:
        print(f"‚ùå Supabase connection failed: {e}")
        print("Please check your SUPABASE_URL and SUPABASE_SERVICE_KEY in .env file")


if __name__ == "__main__":
    asyncio.run(test_supabase_connection())

---

## FILE: scripts/test_telegram_bot.py
"""Test Telegram bot connection."""

import asyncio
import os

from dotenv import load_dotenv
from telegram import Bot

load_dotenv()


async def test_bot() -> None:
    """Test bot token and get bot info."""
    token = os.getenv("TELEGRAM_BOT_TOKEN")

    if not token:
        print("‚ùå No TELEGRAM_BOT_TOKEN found in .env")
        return

    try:
        bot = Bot(token=token)
        bot_info = await bot.get_me()

        print("‚úÖ Bot connected successfully!")
        print(f"ü§ñ Bot name: {bot_info.first_name}")
        print(f"üì± Bot username: @{bot_info.username}")
        print(f"üÜî Bot ID: {bot_info.id}")
        print(f"üí¨ Can join groups: {bot_info.can_join_groups}")
        print(f"üìñ Can read all group messages: {bot_info.can_read_all_group_messages}")

    except Exception as e:
        print(f"‚ùå Error connecting to bot: {e}")


if __name__ == "__main__":
    asyncio.run(test_bot())

---

## FILE: migrations/001_initial_schema.sql
-- Initial schema for Telegram AI Bot
-- This file contains the database schema for conversations and user sessions

-- Conversations table to store all chat messages
CREATE TABLE IF NOT EXISTS conversations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id TEXT NOT NULL,
    username TEXT,
    first_name TEXT,
    agent_type TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    message TEXT NOT NULL,
    tokens_used INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User sessions table to track active users and their current agent
CREATE TABLE IF NOT EXISTS user_sessions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id TEXT UNIQUE NOT NULL,
    username TEXT,
    first_name TEXT,
    current_agent TEXT NOT NULL,
    last_active TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for better performance
CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id);
CREATE INDEX IF NOT EXISTS idx_conversations_agent_type ON conversations(agent_type);
CREATE INDEX IF NOT EXISTS idx_conversations_created_at ON conversations(created_at);
CREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_sessions_last_active ON user_sessions(last_active);
---

## FILE: ./main.py
def main():
    print("Hello from telegram-ai-bot-v2!")


if __name__ == "__main__":
    main()

---

